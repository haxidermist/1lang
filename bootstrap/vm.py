"""
Virtual Machine for the 1 programming language.
Executes bytecode generated by the compiler.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from codegen import OpCode, Instruction, Function, BytecodeModule
from one_builtins import BUILTINS
import sys


@dataclass
class StackFrame:
    """Call stack frame"""
    function: Function
    ip: int = 0  # Instruction pointer
    locals: Dict[str, Any] = field(default_factory=dict)
    return_address: int = 0


class VMError(Exception):
    """Runtime error in VM"""
    pass


class VM:
    """Virtual Machine for executing 1 bytecode"""

    def __init__(self, module: BytecodeModule):
        self.module = module
        self.stack: List[Any] = []
        self.call_stack: List[StackFrame] = []
        self.globals: Dict[str, Any] = {}
        self.current_frame: Optional[StackFrame] = None
        self.halted = False

    def run(self, entry_point: str = "main") -> Any:
        """Run the program starting at entry point"""
        if entry_point not in self.module.functions:
            raise VMError(f"Entry point '{entry_point}' not found")

        # Call entry point function
        entry_func = self.module.functions[entry_point]
        frame = StackFrame(function=entry_func)
        self.call_stack.append(frame)
        self.current_frame = frame

        try:
            result = self.execute()
            return result
        except Exception as e:
            self.dump_state()
            raise

    def execute(self) -> Any:
        """Execute instructions until halt or return"""
        while not self.halted and self.call_stack:
            frame = self.current_frame

            # Check if we've run past the end
            if frame.ip >= len(frame.function.instructions):
                # Implicit return
                return None

            # Fetch instruction
            inst = frame.function.instructions[frame.ip]
            frame.ip += 1

            # Execute instruction
            try:
                self.execute_instruction(inst)
            except Exception as e:
                print(f"Error executing instruction at {frame.ip - 1}: {inst}")
                print(f"  Error: {e}")
                raise

        # Return top of stack if present
        if self.stack:
            return self.stack[-1]
        return None

    def execute_instruction(self, inst: Instruction):
        """Execute a single instruction"""
        opcode = inst.opcode

        if opcode == OpCode.LOAD_CONST:
            self.stack.append(inst.operand)

        elif opcode == OpCode.LOAD_VAR:
            var_name = inst.operand

            # Look in locals first
            if var_name in self.current_frame.locals:
                value = self.current_frame.locals[var_name]
            # Then in function parameters (stored at frame creation)
            elif var_name in self.globals:
                value = self.globals[var_name]
            else:
                raise VMError(f"Undefined variable: {var_name}")

            self.stack.append(value)

        elif opcode == OpCode.STORE_VAR:
            var_name = inst.operand
            value = self.stack.pop()
            self.current_frame.locals[var_name] = value

        elif opcode == OpCode.POP:
            self.stack.pop()

        # Arithmetic operations
        elif opcode == OpCode.ADD:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a + b)

        elif opcode == OpCode.SUB:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a - b)

        elif opcode == OpCode.MUL:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a * b)

        elif opcode == OpCode.DIV:
            b = self.stack.pop()
            a = self.stack.pop()
            if b == 0:
                raise VMError("Division by zero")
            self.stack.append(a / b)

        elif opcode == OpCode.MOD:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a % b)

        elif opcode == OpCode.POW:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a ** b)

        elif opcode == OpCode.NEG:
            a = self.stack.pop()
            self.stack.append(-a)

        # Comparison operations
        elif opcode == OpCode.EQ:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a == b)

        elif opcode == OpCode.NE:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a != b)

        elif opcode == OpCode.LT:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a < b)

        elif opcode == OpCode.GT:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a > b)

        elif opcode == OpCode.LE:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a <= b)

        elif opcode == OpCode.GE:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a >= b)

        # Logical operations
        elif opcode == OpCode.AND:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a and b)

        elif opcode == OpCode.OR:
            b = self.stack.pop()
            a = self.stack.pop()
            self.stack.append(a or b)

        elif opcode == OpCode.NOT:
            a = self.stack.pop()
            self.stack.append(not a)

        # Control flow
        elif opcode == OpCode.JUMP:
            self.current_frame.ip = inst.operand

        elif opcode == OpCode.JUMP_IF_FALSE:
            condition = self.stack.pop()
            if not condition:
                self.current_frame.ip = inst.operand

        elif opcode == OpCode.JUMP_IF_TRUE:
            condition = self.stack.pop()
            if condition:
                self.current_frame.ip = inst.operand

        # Function operations
        elif opcode == OpCode.CALL:
            func_name, arg_count = inst.operand

            # Pop arguments from stack
            args = []
            for _ in range(arg_count):
                args.insert(0, self.stack.pop())

            # Check if it's a built-in function
            if func_name in BUILTINS:
                result = BUILTINS[func_name](*args)
                self.stack.append(result)
            elif func_name in self.module.functions:
                # User-defined function
                called_func = self.module.functions[func_name]
                new_frame = StackFrame(
                    function=called_func,
                    return_address=self.current_frame.ip
                )

                # Store arguments as local variables using actual parameter names
                for i, arg in enumerate(args):
                    if i < len(called_func.param_names):
                        new_frame.locals[called_func.param_names[i]] = arg
                    else:
                        new_frame.locals[f"arg{i}"] = arg

                # Push frame and switch to it
                self.call_stack.append(new_frame)
                self.current_frame = new_frame
            else:
                raise VMError(f"Undefined function: {func_name}")

        elif opcode == OpCode.RETURN:
            return_value = self.stack.pop() if self.stack else None

            # Pop current frame
            self.call_stack.pop()

            if self.call_stack:
                # Return to previous frame
                self.current_frame = self.call_stack[-1]
                # Push return value onto stack
                if return_value is not None:
                    self.stack.append(return_value)
            else:
                # No more frames - program done
                self.halted = True
                if return_value is not None:
                    self.stack.append(return_value)

        elif opcode == OpCode.HALT:
            self.halted = True

        # List operations
        elif opcode == OpCode.BUILD_LIST:
            count = inst.operand
            elements = []
            for _ in range(count):
                elements.insert(0, self.stack.pop())
            self.stack.append(elements)

        elif opcode == OpCode.INDEX:
            index = self.stack.pop()
            obj = self.stack.pop()

            if isinstance(obj, list):
                if not isinstance(index, int):
                    raise VMError(f"List index must be integer, got {type(index)}")
                if index < 0 or index >= len(obj):
                    raise VMError(f"List index out of range: {index}")
                self.stack.append(obj[index])
            elif isinstance(obj, str):
                if not isinstance(index, int):
                    raise VMError(f"String index must be integer, got {type(index)}")
                if index < 0 or index >= len(obj):
                    raise VMError(f"String index out of range: {index}")
                self.stack.append(obj[index])
            else:
                raise VMError(f"Cannot index type {type(obj)}")

        # Built-in functions
        elif opcode == OpCode.PRINT:
            value = self.stack.pop()
            print(value, end='')
            self.stack.append(None)  # print returns None

        elif opcode == OpCode.PRINTLN:
            value = self.stack.pop()
            print(value)
            self.stack.append(None)  # println returns None

        else:
            raise VMError(f"Unknown opcode: {opcode}")

    def dump_state(self):
        """Dump VM state for debugging"""
        print("\n=== VM State ===")
        print(f"Halted: {self.halted}")
        print(f"Stack: {self.stack}")
        print(f"Call stack depth: {len(self.call_stack)}")

        if self.current_frame:
            print(f"\nCurrent frame:")
            print(f"  Function: {self.current_frame.function.name}")
            print(f"  IP: {self.current_frame.ip}")
            print(f"  Locals: {self.current_frame.locals}")

        print("\nGlobals:", self.globals)
        print("================\n")


def run_bytecode(module: BytecodeModule, entry_point: str = "main", debug: bool = False) -> Any:
    """Run bytecode module"""
    vm = VM(module)

    if debug:
        print("=== Starting execution ===")
        print(f"Entry point: {entry_point}\n")

    result = vm.run(entry_point)

    if debug:
        print(f"\n=== Execution complete ===")
        print(f"Result: {result}")

    return result
