// mini_vm.one - Tiny stack-based VM written in 1
// This demonstrates 1 executing bytecode!

// Opcodes
function OP_PUSH:
  outputs:
    op: Integer
  implementation: {
    return 1
  }

function OP_ADD:
  outputs:
    op: Integer
  implementation: {
    return 2
  }

function OP_SUB:
  outputs:
    op: Integer
  implementation: {
    return 3
  }

function OP_MUL:
  outputs:
    op: Integer
  implementation: {
    return 4
  }

function OP_PRINT:
  outputs:
    op: Integer
  implementation: {
    return 5
  }

function OP_HALT:
  outputs:
    op: Integer
  implementation: {
    return 6
  }

// Execute bytecode
// Bytecode format: [op, operand, op, operand, ...]
// Stack is simulated with 100 slots
function execute:
  inputs:
    code: String
  outputs:
    result: Integer
  implementation: {
    // Initialize stack (max 100 elements)
    stack_0 = 0
    stack_1 = 0
    stack_2 = 0
    stack_3 = 0
    stack_4 = 0
    sp = 0  // Stack pointer

    // Parse and execute bytecode
    // For simplicity, we'll use a string like "1,5,1,3,2,5,6"
    // Which means: PUSH 5, PUSH 3, ADD, PRINT, HALT

    pos = 0
    code_len = len(code)
    running = 1

    while running == 1: {
      if pos >= code_len: {
        running = 0
        break
      }

      // Read opcode (simplified - read until comma or end)
      start = pos
      while pos < code_len: {
        c = char_at(code, pos)
        if str_eq(c, ","): {
          break
        }
        pos = pos + 1
      }

      op_str = substr(code, start, pos)
      op = str_to_int(op_str)

      // Skip comma
      if pos < code_len: {
        pos = pos + 1
      }

      // Execute operation
      if op == 1: {
        // OP_PUSH: read operand
        start = pos
        while pos < code_len: {
          c = char_at(code, pos)
          if str_eq(c, ","): {
            break
          }
          pos = pos + 1
        }

        val_str = substr(code, start, pos)
        val = str_to_int(val_str)

        // Push to stack
        if sp == 0: {
          stack_0 = val
          sp = 1
        } else: {
          if sp == 1: {
            stack_1 = val
            sp = 2
          } else: {
            if sp == 2: {
              stack_2 = val
              sp = 3
            } else: {
              if sp == 3: {
                stack_3 = val
                sp = 4
              } else: {
                stack_4 = val
                sp = 5
              }
            }
          }
        }

        // Skip comma
        if pos < code_len: {
          pos = pos + 1
        }

      } else: {
        if op == 2: {
          // OP_ADD
          if sp >= 2: {
            // Pop two values
            if sp == 2: {
              b = stack_1
              a = stack_0
              stack_0 = a + b
              sp = 1
            } else: {
              if sp == 3: {
                b = stack_2
                a = stack_1
                stack_1 = a + b
                sp = 2
              } else: {
                if sp == 4: {
                  b = stack_3
                  a = stack_2
                  stack_2 = a + b
                  sp = 3
                } else: {
                  b = stack_4
                  a = stack_3
                  stack_3 = a + b
                  sp = 4
                }
              }
            }
          }
        } else: {
          if op == 3: {
            // OP_SUB
            if sp >= 2: {
              if sp == 2: {
                b = stack_1
                a = stack_0
                stack_0 = a - b
                sp = 1
              } else: {
                if sp == 3: {
                  b = stack_2
                  a = stack_1
                  stack_1 = a - b
                  sp = 2
                }
              }
            }
          } else: {
            if op == 4: {
              // OP_MUL
              if sp >= 2: {
                if sp == 2: {
                  b = stack_1
                  a = stack_0
                  stack_0 = a * b
                  sp = 1
                } else: {
                  if sp == 3: {
                    b = stack_2
                    a = stack_1
                    stack_1 = a * b
                    sp = 2
                  }
                }
              }
            } else: {
              if op == 5: {
                // OP_PRINT
                if sp > 0: {
                  if sp == 1: {
                    println(stack_0)
                  } else: {
                    if sp == 2: {
                      println(stack_1)
                    } else: {
                      if sp == 3: {
                        println(stack_2)
                      }
                    }
                  }
                }
              } else: {
                if op == 6: {
                  // OP_HALT
                  running = 0
                }
              }
            }
          }
        }
      }
    }

    return 0
  }

// Test the VM
function main:
  outputs:
    exit_code: Integer
  implementation: {
    println("Mini VM - Written in 1!")
    println("=======================")
    println("")

    // Test program: PUSH 10, PUSH 5, ADD, PRINT, HALT
    // Bytecode: 1,10,1,5,2,5,6
    println("Program 1: 10 + 5")
    code1 = "1,10,1,5,2,5,6"
    println("Bytecode: 1,10,1,5,2,5,6")
    print("Result: ")
    execute(code1)
    println("")

    // Test program: PUSH 20, PUSH 8, SUB, PRINT, HALT
    // Bytecode: 1,20,1,8,3,5,6
    println("Program 2: 20 - 8")
    code2 = "1,20,1,8,3,5,6"
    println("Bytecode: 1,20,1,8,3,5,6")
    print("Result: ")
    execute(code2)
    println("")

    // Test program: PUSH 6, PUSH 7, MUL, PRINT, HALT
    // Bytecode: 1,6,1,7,4,5,6
    println("Program 3: 6 * 7")
    code3 = "1,6,1,7,4,5,6"
    println("Bytecode: 1,6,1,7,4,5,6")
    print("Result: ")
    execute(code3)
    println("")

    println("Success! 1 can execute bytecode!")

    return 0
  }
